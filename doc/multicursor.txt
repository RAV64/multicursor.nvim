*multicursor.txt*        multiple cursors in Neovim which work how you expect.

==============================================================================
Table of Contents                              *multicursor-table-of-contents*

1. Features                                             |multicursor-features|
2. Example Configuration                   |multicursor-example-configuration|
  • Selecting Cursors                          |multicursor-selecting-cursors|
  • Changing Cursors                            |multicursor-changing-cursors|
  • Using Cursors                                  |multicursor-using-cursors|
3. API                                                       |multicursor-API|
  • Types                                              |multicursor-API-Types|
  • Context Methods                                  |multicursor-API-Context|
  • Cursor Methods                                    |multicursor-API-Cursor|

==============================================================================
Features                                                *multicursor-features*

    • Visual and select modes with char/line/block selections
    • Normal, insert, replace modes
    • Undo/redo
    • Virtualedit
    • Autocompletion
    • Snippet expansion (use `vim.snippet.expand`)
    • Cursor specific registers for searching and yanking
    • Match & split cursor selections with regex
    • Transpose cursor selections
    • Align cursor columns
    • Easily extended with the Cursor API
    • Works with most plugins and remaps


==============================================================================
Example Configuration                      *multicursor-example-configuration*

basic usage of multicursor.nvim with the default config.

>lua
    {
        "jake-stewart/multicursor.nvim",
        branch = "1.0",
        config = function()
            local mc = require("multicursor-nvim")

            mc.setup()

            local set = vim.keymap.set

            -- Add or skip cursor above/below the main cursor.
            set({"n", "v"}, "<up>",
                function() mc.lineAddCursor(-1) end)
            set({"n", "v"}, "<down>",
                function() mc.lineAddCursor(1) end)
            set({"n", "v"}, "<leader><up>",
                function() mc.lineSkipCursor(-1) end)
            set({"n", "v"}, "<leader><down>",
                function() mc.lineSkipCursor(1) end)

            -- Add or skip adding a new cursor by matching word/selection
            set({"n", "v"}, "<leader>n",
                function() mc.matchAddCursor(1) end)
            set({"n", "v"}, "<leader>s",
                function() mc.matchSkipCursor(1) end)
            set({"n", "v"}, "<leader>N",
                function() mc.matchAddCursor(-1) end)
            set({"n", "v"}, "<leader>S",
                function() mc.matchSkipCursor(-1) end)

            -- Add all matches in the document
            set({"n", "v"}, "<leader>A", mc.matchAllAddCursors)

            -- You can also add cursors with any motion you prefer:
            -- set("n", "<right>", function()
            --     mc.addCursor("w")
            -- end)
            -- set("n", "<leader><right>", function()
            --     mc.skipCursor("w")
            -- end)

            -- Rotate the main cursor.
            set({"n", "v"}, "<left>", mc.nextCursor)
            set({"n", "v"}, "<right>", mc.prevCursor)

            -- Delete the main cursor.
            set({"n", "v"}, "<leader>x", mc.deleteCursor)

            -- Add and remove cursors with control + left click.
            set("n", "<c-leftmouse>", mc.handleMouse)

            -- Easy way to add and remove cursors using the main cursor.
            set({"n", "v"}, "<c-q>", mc.toggleCursor)

            -- Clone every cursor and disable the originals.
            set({"n", "v"}, "<leader><c-q>", mc.duplicateCursors)

            set("n", "<esc>", function()
                if not mc.cursorsEnabled() then
                    mc.enableCursors()
                elseif mc.hasCursors() then
                    mc.clearCursors()
                else
                    -- Default <esc> handler.
                end
            end)

            -- bring back cursors if you accidentally clear them
            set("n", "<leader>gv", mc.restoreCursors)

            -- Align cursor columns.
            set("n", "<leader>a", mc.alignCursors)

            -- Split visual selections by regex.
            set("v", "S", mc.splitCursors)

            -- Append/insert for each line of visual selections.
            set("v", "I", mc.insertVisual)
            set("v", "A", mc.appendVisual)

            -- match new cursors within visual selections by regex.
            set("v", "M", mc.matchCursors)

            -- Rotate visual selection contents.
            set("v", "<leader>t",
                function() mc.transposeCursors(1) end)
            set("v", "<leader>T",
                function() mc.transposeCursors(-1) end)

            -- Jumplist support
            set({"v", "n"}, "<c-i>", mc.jumpForward)
            set({"v", "n"}, "<c-o>", mc.jumpBackward)

            -- Customize how cursors look.
            local hl = vim.api.nvim_set_hl
            hl(0, "MultiCursorCursor", { link = "Cursor" })
            hl(0, "MultiCursorVisual", { link = "Visual" })
            hl(0, "MultiCursorSign", { link = "SignColumn"})
            hl(0, "MultiCursorDisabledCursor", { link = "Visual" })
            hl(0, "MultiCursorDisabledVisual", { link = "Visual" })
            hl(0, "MultiCursorDisabledSign", { link = "SignColumn"})
        end
    }
<
==============================================================================
Selecting Cursors                              *multicursor-selecting-cursors*

- You can add cursors above/below the current cursor with `<up>` and `<down>`.
- You can skip a line with `<leader><up>` or `<leader><down>`.
- You can match the word/selection under the cursor forwards or backwards with
  `<leader>n` and `<leader>N`.
- You can skip a match forwards or backwards using `<leader>s` and
  `<leader>S`.
- You can add and remove cursors using the mouse with `<c-leftmouse>`.

==============================================================================
Changing Cursors                                *multicursor-changing-cursors*

- You can rotate through cursors with `<left>` and `<right>`.
- You can delete the current cursor using `<leader>x`
- You can disable cursors with `<c-q>`, which means only the main cursor
  moves.
- You can also press `<leader><c-q>` to duplicate cursors, disabling the
  originals.
- When cursors are disabled, you can press `<c-q>` to add a cursor under the
  main cursor.
- You can press `<esc>` to enable cursors again.

==============================================================================
Using Cursors                                      *multicursor-using-cursors*

- Once you have your cursors, you use vim normally as you would with a single
  cursor.
- You can press `<leader>a` to align cursor columns.
- You can press `S` to split a visual selection by regex into multiple
  selections.
- You can press `M` to run a regex within your visual selection, creating
  a new cursor for each match.
- You can press `<leader>t` and `<leader>T` to transpose visual selections,
  which means the text within each visual selection will be rotated between
  cursors.


- When you want to collapse your cursors back into one, press `<esc>`.

==============================================================================
API                                                          *multicursor-API*

All of the provided features are implemented using the Cursor API, which is
accessible for writing your own complex multi-cursor logic.

You can use the Cursor API by calling `mc.action` with a callback, like so:

>lua
    mc.action(function(ctx)
	local cursors = ctx:getCursors()
    end)
<

The `ctx` is a `CursorContext` which lets you query for cursors.
In the snippet, we simply called `getCursors()` to get a list of all our cursors.

In the next snippet, we will instead call `firstCursor()` to get only the
highest cursor in the document. Once we have our cursor, we can interact with it.

>lua
    mc.action(function(ctx)
	local cursor = ctx:firstCursor()
	vim.print(cursor:getLine())
	cursor:feedkeys("ihello world")
    end)
>

And that's it. You can view the prototypes below to
see all the default features implemented using the Cursor API.

==============================================================================
Types                                                  *multicursor-API-Types*
CursorQuery                                    *multicursor-types-CursorQuery*
>lua
    --- @alias CursorQuery {disableCursors?: boolean, enableCursors?: boolean}
<
    Fields: ~
      • disableCursors (`boolean?`) if true return disable cursors
      • enableCursors (`boolean?`) if true return enabled cursors

Pos                                                    *multicursor-types-Pos*
>lua
    --- @alias Pos [integer, integer, integer]
<
    Fields: ~
      • 1 (`integer`) 1-indexed line
      • 2 (`integer`) 1-indexed col
      • 3 (`integer`) offset

SimplePos                                        *multicursor-types-SimplePos*
>lua
    --- @alias SimplePos [integer, integer]
<
    Fields: ~
      • 1 (`integer`) 1-indexed line
      • 2 (`integer`) 1-indexed col

==============================================================================

mc.addCursor({motion})                                 *multicursor-addCursor*
    Add a cursor and move only the main cursor using motion.

    Usage example: >lua
        vim.keymap.set("n", "<right>", function()
            mc.addCursor("w")
        end)
<

    Parameters: ~
      • {motion} (`string`) motion to execute on the main cursor leaving a new
      cursor behind

mc.skipCursor({motion})                               *multicursor-skipCursor*
    Move only the main cursor using motion.

    Usage example: >lua
        vim.keymap.set("n", "<leader><right>", function()
            mc.skipCursor("w")
        end)
<

    Parameters: ~
      • {motion} (`string`) motion to execute on the main cursor without
      adding a new cursor

mc.lineAddCursor({direction})                      *multicursor-lineAddCursor*
    Add a cursor above or below the the main cursor, skipping empty lines.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<up>", function()
            mc.lineAddCursor(-1)
        end)
        vim.keymap.set({"n", "v"}, "<down>", function()
            mc.lineAddCursor(1)
        end)
<

    Parameters: ~
      • {direction} (`-1 | 1`) when passing in `-1` spawn a cursor in the
      previous line, while `1` spawn in the next line

mc.lineSkipCursor({direction})                    *multicursor-lineSkipCursor*
    Move only the main cursor up or down a line, skipping empty lines.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<leader><up>", function()
            mc.lineSkipCursor(-1)
        end)
        vim.keymap.set({"n", "v"}, "<leader><down>", function()
            mc.lineSkipCursor(1)
        end)
<

    Parameters: ~
      • {direction} (`-1 | 1`) when passing in `-1` spawn a cursor in the
      previous line, while `1` spawn in the next line

mc.matchAddCursor({direction})                    *multicursor-matchAddCursor*
    Add a new cursor by matching the current word/selection.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<leader>n", function()
            mc.matchAddCursor(1)
        end)
        vim.keymap.set({"n", "v"}, "<leader>s", function()
            mc.matchSkipCursor(1)
        end)
<

    Parameters: ~
      • {direction} (`-1 | 1`) when passing in `-1` spawn a cursor in the
      previous line, while `1` spawn in the next line

mc.matchSkipCursor({direction})                  *multicursor-matchSkipCursor*
    Move only the main cursor by matching the current word/selection.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<leader>N", function()
            mc.matchAddCursor(-1)
        end)
        vim.keymap.set({"n", "v"}, "<leader>S", function()
            mc.matchSkipCursor(-1)
        end)
<

    Parameters: ~
      • {direction} (`-1 | 1`) when passing in `-1` spawn a cursor in the
      previous line, while `1` spawn in the next line

mc.matchAllAddCursors()                       *multicursor-matchAllAddCursors*
    Add a cursor for every match of the word/selection under the cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<leader>A", mc.matchAllAddCursors)
<

mc.nextCursor()                                       *multicursor-nextCursor*
    Select the cursor after the main cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<left>", mc.nextCursor)
<

mc.prevCursor()                                       *multicursor-prevCursor*
    Select the cursor before the main cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<right>", mc.prevCursor)
<

mc.firstCursor()                                     *multicursor-firstCursor*
    Select the first cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "H", mc.firstCursor)
<

mc.lastCursor()                                       *multicursor-lastCursor*
    Select the last cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "L", mc.lastCursor)
<

mc.hasCursors()                                       *multicursor-hasCursors*
    Returns whether multiple cursors exist.

    Usage example: >lua
        vim.keymap.set({ "n", "v" }, "<esc>", function()
            if mc.hasCursors() then
                mc.clearCursors()
            end
        end)
<

    Return: ~
      • (`boolean`) true if there are more than 1 cursors

mc.deleteCursor()                                   *multicursor-deleteCursor*
    Delete the main cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<leader>x", mc.deleteCursor)
<

mc.clearCursors()                                   *multicursor-clearCursors*
    Clear all cursors except main cursor.

    Usage example: >lua
        vim.keymap.set({ "n", "v" }, "<esc>", function()
            if mc.hasCursors() then
                mc.clearCursors()
            end
        end)
<

mc.handleMouse()                                     *multicursor-handleMouse*
    Use in a mouse mapping to handle mouse input.

    Usage example: >lua
        vim.keymap.set("n", "<c-leftmouse>", mc.handleMouse)
<

mc.alignCursors()                                   *multicursor-alignCursors*
    Align columns of cursors on multiple lines.

    Usage example: >lua
        vim.keymap.set("n", "<leader>a", mc.alignCursors)
<

mc.splitCursors()                                   *multicursor-splitCursors*
    Split visual selections with a regex separator. For example, visually
    selecting "a,b,c,d" and splitting with "," will create four cursors, one
    on each letter.

    Usage example: >lua
        vim.keymap.set("v", "S", mc.splitCursors)
<

mc.matchCursors()                                   *multicursor-matchCursors*

    Match a pattern over a visual selection, creating a new cursor for each match.
    For example, visually selecting "foo bar foo" and matching with "foo" will
    create two cursors, one on each "foo"

    Usage example: >lua
        vim.keymap.set("v", "M", mc.matchCursors)
<

mc.transposeCursors(direction)                  *multicursor-transposeCursors*
    Rotate the contents of each visual selection for each cursor.

    Usage example: >lua
        vim.keymap.set("v", "<leader>t", function()
            mc.transposeCursors(1)
        end)
        vim.keymap.set("v", "<leader>T", function()
            mc.transposeCursors(-1)
        end)
<

    Parameters: ~
      • {direction} (`-1 | 1`) With `1` for clockwise rotation and `-1` for
      anti-clockwise.

mc.insertVisual()                                   *multicursor-insertVisual*
    Create a cursor for each line of the visual selection, and enter insert
    mode with `I`

    Usage example: >lua
        vim.keymap.set("v", "I", mc.insertVisual)
<

mc.appendVisual()                                   *multicursor-appendVisual*
    Create a cursor for each line of the visual selection, and enter insert
    mode with `A`
    Usage example: >lua
        vim.keymap.set("v", "A", mc.appendVisual)
<

mc.disableCursors()                               *multicursor-disableCursors*
    Locks the cursors from moving. This is useful for repositioning main
    cursor for adding more cursors.
    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<c-q>", mc.disableCursors)
<

    See also: ~
      • |multicursor-enableCursors|

mc.enableCursors()                                 *multicursor-enableCursors*
Unlocks the cursors from moving.
    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<c-q>", mc.enableCursors)
<

    See also: ~
      • |multicursor-disableCursors|

mc.cursorsEnabled()                               *multicursor-cursorsEnabled*
    Returns whether the cursors are locked from moving.

    Usage example: >lua
        if not mc.cursorsEnabled() then
            mc.enableCursors()
        end
<

    Return: ~
      • (`boolean`) true if cursors are locked

    See also: ~
      • |multicursor-disableCursors|
      • |multicursor-enableCursors|

mc.feedkeys({keys}, {opts})                           *multicursor-feedkeys*
    Use instead of `vim.fn.feedkeys()` or `vim.api.nvim_feedkeys()` in
    multicursor mappings to avoid bugs.

    Usage example: >lua
<

    Parameters: ~
      • {keys} (`string`) string representing a command
      • {opts} (`table`) options
        • {opts.remap} (`boolean?`) if true use remapped keys
        • {opts.keycodes} (`boolean?`) if true translate keycodes

mc.action(func)                                           *multicursor-action*
    Perform a complex action using the Cursor API. See below for details.

    Usage example: >lua
        mc.action(function(ctx)
            local cursors = ctx:getCursors()
        end)
<

    Parameters: ~
      • {func} (`function`) function to execute on cursors
        • {ctx} (`CursorContext`) allows to query for cursors

==============================================================================
Context Methods                                      *multicursor-API-Context*

    • setCursorsEnabled                    |multicursor-ctx-setCursorsEnabled|
    • getCursors                                  |multicursor-ctx-getCursors|
    • addCursor                                    |multicursor-ctx-addCursor|
    • forEachCursor                            |multicursor-ctx-forEachCursor|
    • mapCursors                                  |multicursor-ctx-mapCursors|
    • findLastCursor                          |multicursor-ctx-findLastCursor|
    • findCursor                                  |multicursor-ctx-findCursor|
    • nextCursor                                  |multicursor-ctx-nextCursor|
    • prevCursor                                  |multicursor-ctx-prevCursor|
    • nearestCursor                            |multicursor-ctx-nearestCursor|
    • getCursorAtPos                          |multicursor-ctx-getCursorAtPos|
    • overlappedCursor                      |multicursor-ctx-overlappedCursor|
    • mainCursor                                  |multicursor-ctx-mainCursor|
    • firstCursor                                |multicursor-ctx-firstCursor|
    • lastCursor                                  |multicursor-ctx-lastCursor|
    • cursorsEnabled                          |multicursor-ctx-cursorsEnabled|
    • hasCursors                                  |multicursor-ctx-hasCursors|
    • clear                                            |multicursor-ctx-clear|



ctx:setCursorsEnabled({value})             *multicursor-ctx-setCursorsEnabled*
    Enables or disables all cursors >lua
    --- @param value boolean
<
    Parameters: ~
      • {value} (`boolean`)

ctx:getCursors({opts})                            *multicursor-ctx-getCursors*
    Returns a list of cursors, sorted by their position. >lua
    --- @param opts? CursorQuery
    --- @return Cursor[]
<
    Parameters: ~
      • (`table`) CursorQuery table

    Return: ~
      • (`table`) table of `Cursor` objects

    See also: ~
      • |multicursor-API-Cursor|
      • |multicursor-types-CursorQuery|

ctx:addCursor()                                    *multicursor-ctx-addCursor*
    Clones and returns the main cursor >lua
    --- @return Cursor
<
    Return: ~
      • (`table`) `Cursor` object

    See also: ~
      • |multicursor-API-Cursor|

ctx:forEachCursor({callback}, {opts?})         *multicursor-ctx-forEachCursor*
    Util which executes callback for each cursor, sorted by their position. >lua
    --- @param callback fun(cursor: Cursor, i: integer, t: Cursor[])
    --- @param opts? CursorQuery
<
    Parameters: ~
      • {callback} (`function`) a function that will be executed on each
        cursor
      • {opts?} (`CursorQuery`) type of cursor to search for

    See also: ~
      • |multicursor-API-Cursor|
      • |multicursor-types-CursorQuery|

ctx:mapCursors({callback}, {opts?})               *multicursor-ctx-mapCursors*
    Util method which maps each cursor to a value. >lua
    --- @generic T
    --- @param callback fun(cursor: Cursor, i: integer, t: Cursor[]): T
    --- @param opts? CursorQuery
    --- @return T[]
<
    Parameters: ~
      • {callback} (`function`) a function that will be executed on each
        cursor
      • {opts?} (`CursorQuery`) type of cursor to search for

    Return: ~
      • (`table`) table with mapped results

    See also: ~
      • |multicursor-API-Cursor|
      • |multicursor-types-CursorQuery|

ctx:findLastCursor({predicate}, {opts?})      *multicursor-ctx-findLastCursor*
    Util method which returns the last cursor matching the predicate. >lua
    --- @param predicate fun(cursor: Cursor, i: integer, t: Cursor[]): any
    --- @param opts? CursorQuery
    --- @return Cursor | nil
<
    Parameters: ~
      • {predicate} (`function`)
      • {opts?} (`CursorQuery`) type of cursor to search for

    Return: ~
      • (`Cursor | nil`) returns the last cursor matching predicate or nil if
        no cursors were found

    See also: ~
      • |multicursor-API-Cursor|
      • |multicursor-types-CursorQuery|

ctx:findCursor({predicate}, {opts?})              *multicursor-ctx-findCursor*
    Util method which returns the first cursor matching the predicate. >lua
    --- @param predicate fun(cursor: Cursor, i: integer, t: Cursor[]): any
    --- @param opts? CursorQuery
    --- @return Cursor | nil
<

    Parameters: ~
      • {predicate} (`function`)
      • {opts?} (`CursorQuery`) type of cursor to search for

    Return: ~
      • (`Cursor | nil`) returns the first cursor matching predicate or nil if
        no cursors were found

    See also: ~
      • |multicursor-API-Cursor|
      • |multicursor-types-CursorQuery|

ctx:nextCursor({pos}, {opts?})                    *multicursor-ctx-nextCursor*
    Returns the closest cursor which appears AFTER pos. A cursor exactly at
    pos will not be returned. It does not wrap, so if none are found, then nil
    is returned. If you wish to wrap, use `ctx:nextCursor(...) or
    ctx:firstCursor(...)`. >lua
    --- @param pos SimplePos | Pos
    --- @param opts? CursorQuery
    --- @return Cursor | nil
<

    Parameters: ~
      • {pos} (`SimplePos | Pos`) position to search from
      • {opts?} (`CursorQuery`) type of cursor to search for

    Return: ~
      • (`Cursor | nil`) returns the closest cursor after the pos or nil if
        none are found

    See also: ~
      • |multicursor-API-Cursor|
      • |multicursor-types-CursorQuery|
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|

ctx:prevCursor({pos}, {opts?})                    *multicursor-ctx-prevCursor*
    Returns the closest cursor which appears BEFORE pos. A cursor exactly at
    pos will not be returned. It does not wrap, so if none are found, then nil
    is returned. If you wish to wrap, use `ctx:prevCursor(...) or
    ctx:lastCursor(...)`. >lua
    --- @param pos SimplePos | Pos
    --- @param opts? CursorQuery
    --- @return Cursor | nil
<
    Parameters: ~
      • {pos} (`SimplePos | Pos`) position to search from
      • {opts?} (`CursorQuery`) type of cursor to search for

    Return: ~
      • (`Cursor | nil`) returns the closest cursor before the pos or nil if
        none are found

    See also: ~
      • |multicursor-API-Cursor|
      • |multicursor-types-CursorQuery|
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|

ctx:nearestCursor({pos}, {opts?})              *multicursor-ctx-nearestCursor*
    Returns the nearest cursor to pos, and accepts a cursor exactly at pos. >lua
    --- @param pos SimplePos | Pos
    --- @param opts? CursorQuery
    --- @return Cursor | nil
<

    Parameters: ~
      • {pos} (`SimplePos | Pos`) position to search from
      • {opts?} (`CursorQuery`) type of cursor to search for

    Return: ~
      • (`Cursor | nil`) returns closest cursor or nil if none found

    See also: ~
      • |multicursor-API-Cursor|
      • |multicursor-types-CursorQuery|
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|

ctx:getCursorAtPos({pos}, {opts?})            *multicursor-ctx-getCursorAtPos*
    Returns the exact cursor from pos >lua
    --- @param pos SimplePos | Pos
    --- @param opts? CursorQuery
    --- @return Cursor | nil
<
    Parameters: ~
      • {pos} (`SimplePos | Pos`) position to search at
      • {opts?} (`CursorQuery`) type of cursor to search for

    Return: ~
      • (`Cursor | nil`) returns the cursor or nil if there are no cursors at
      position

    See also: ~
      • |multicursor-API-Cursor|
      • |multicursor-types-CursorQuery|
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|

ctx:overlappedCursor()                      *multicursor-ctx-overlappedCursor*
    Returns the cursor under the main cursor >lua
    --- @return Cursor | nil
<
    Return: ~
      • (`Cursor | nil`) returns cursor under the main cursor

    See also: ~
      • |multicursor-API-Cursor|
    
ctx:mainCursor()                                  *multicursor-ctx-mainCursor*
    Returns the main cursor. >lua
    --- @return Cursor
<
    Return: ~
      • (`Cursor`) return the main cursor

    See also: ~
      • |multicursor-API-Cursor|

ctx:firstCursor({opts?})                         *multicursor-ctx-firstCursor*
    Returns the cursor closest to the start of the document. >lua
    --- @param opts? CursorQuery
    --- @return Cursor | nil
<
    Parameters: ~
      • {opts?} (`CursorQuery`) type of cursor to search for

    Return: ~
      • (`Cursor | nil`) returns the first cursor in the document or nil if
        there are none

    See also: ~
      • |multicursor-API-Cursor|
      • |multicursor-types-CursorQuery|

ctx:lastCursor({opts?})                           *multicursor-ctx-lastCursor*
    Returns the cursor closest to the end of the document. >lua
    --- @param opts? CursorQuery
    --- @return Cursor | nil
<
    Parameters: ~
      • {opts?} (`CursorQuery`) type of cursor to search for

    Return: ~
      • (`Cursor | nil`) returns the last cursor in the document or nil if
        there are none

    See also: ~
      • |multicursor-API-Cursor|
      • |multicursor-types-CursorQuery|

ctx:cursorsEnabled()                          *multicursor-ctx-cursorsEnabled*
    Returns whether all cursors are enabled >lua
    --- @return boolean
<
    Return: ~
      • (`boolean`) true if ALL cursors are enabled

ctx:hasCursors()                                  *multicursor-ctx-hasCursors*
    Returns whether there are cursors >lua
    --- @return boolean
<
    Return: ~
      • (`boolean`) true if there are any cursor spawned

ctx:clear()                                            *multicursor-ctx-clear*
    Removes all cursors

==============================================================================
Cursor Methods                                        *multicursor-API-Cursor*

Cursor:line()                                        |multicursor-cursor-line|
Cursor:col()                                          |multicursor-cursor-col|
Cursor:getLine()                                  |multicursor-cursor-getLine|
Cursor:delete()                                    |multicursor-cursor-delete|
Cursor:overlappedCursor()                |multicursor-cursor-overlappedCursor|
Cursor:select()                                    |multicursor-cursor-select|
Cursor:isMainCursor()                        |multicursor-cursor-isMainCursor|
Cursor:atVisualStart()                      |multicursor-cursor-atVisualStart|
Cursor:splitVisualLines()                |multicursor-cursor-splitVisualLines|
Cursor:getPos()                                    |multicursor-Cursor-getPos|
Cursor:setPos(pos)                                 |multicursor-Cursor-setPos|
Cursor:setVisualAnchor(pos)               |multicursor-Cursor-setVisualAnchor|
Cursor:getVisualAnchor()                  |multicursor-Cursor-getVisualAnchor|
Cursor:setRedoChangePos(pos)             |multicursor-cursor-setRedoChangePos|
Cursor:clone()                                      |multicursor-cursor-clone|
Cursor:getVisualLines()                    |multicursor-Cursor-getVisualLines|
Cursor:getFullVisualLines()            |multicursor-Cursor-getFullVisualLines|
Cursor:getVisual()                              |multicursor-cursor-getVisual|
Cursor:mode()                                        |multicursor-cursor-mode|
Cursor:setMode(mode)                              |multicursor-cursor-setMode|
Cursor:disable()                                  |multicursor-cursor-disable|
Cursor:enable()                                    |multicursor-cursor-enable|
Cursor:feedkeys(keys, opts)                      |multicursor-cursor-feedkeys|
Cursor:perform(callback)                          |multicursor-cursor-perform|
Cursor:getCursorWord(callback)              |multicursor-cursor-getCursorWord|
Cursor:setSearch(search)                        |multicursor-cursor-setSearch|
Cursor:setVisual(visualStart, visualEnd)        |multicursor-cursor-setVisual|
Cursor:inVisualMode()                        |multicursor-cursor-inVisualMode|
Cursor:inSelectMode()                        |multicursor-cursor-inSelectMode|
Cursor:hasSelection()                        |multicursor-cursor-hasSelection|



Cursor:line()                                        *multicursor-cursor-line*
    Returns this cursors current line number, 1 indexed. >lua
    --- @return integer
<

    Return: ~
      • (`integer`) line number

Cursor:col()                                          *multicursor-cursor-col*
    Returns this cursors current column number, 1 indexed. >lua
    --- @return integer
<

    Return: ~
      • (`integer`) column number

Cursor:getLine()                                  *multicursor-cursor-getLine*
    Returns the full line text of where this cursor is located. >lua
    --- @return string
<
    Return: ~
      • (`string`) line text

Cursor:delete()                                    *multicursor-cursor-delete*
    Deletes this cursor. If this is the main cursor then the closest cursor to
    it is set as the new main cursor. If this is the last remaining cursor, a
    new cursor is created at its position.

Cursor:overlappedCursor()                *multicursor-cursor-overlappedCursor*
    Returns the disabled cursor underneath this one, if it exists >lua
    --- @return Cursor | nil
<
    Return: ~
      • (`Cursor | nil`) disabled `Cursor` or nil if there isn't any

    See also: ~
      • |multicursor-API-Cursor|

Cursor:select()                                    *multicursor-cursor-select*
    Sets this cursor as the main cursor. >lua
    --- @return self
<
    Return: ~
      • (`self`) cursor

Cursor:isMainCursor()                        *multicursor-cursor-isMainCursor*
    Returns whether this cursor is the main cursor. >lua
    --- @return boolean
<
    Return: ~
      • (`boolean`) true if it is a main cursor

Cursor:atVisualStart()                      *multicursor-cursor-atVisualStart*
    A cursor can either be at the start or end of a visual selection.
    For example, if you select lines 10-20, your cursor can either be
    on line 10 (start) or 20 (end). this method returns true when at
    the start. >lua
    --- @return boolean
<
    Return: ~
      • (`boolean`) true if the cursor is at the beginning of the selection

Cursor:splitVisualLines()                *multicursor-cursor-splitVisualLines*
    For each line of the cursor's visual selection, a new cursor is
    created, visually selecting only the single line.
    This method deletes the original cursor. >lua
    --- @return Cursor[]
<
    Return: ~
      • (`table`) table of Cursors

Cursor:getPos()                                    *multicursor-Cursor-getPos*
    Returns the position of a cursor >lua
    --- @return Pos
<
    Return: ~
      • (`Pos`) position of the cursor

    See also: ~
      • |multicursor-types-Pos|

Cursor:setPos({pos})                               *multicursor-Cursor-setPos*
    Sets the position of the cursor >lua
    --- @param pos SimplePos | Pos
    --- @return self
<
    See also: ~
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|

Cursor:setVisualAnchor({pos})             *multicursor-Cursor-setVisualAnchor*
    Sets the position of the visual anchor
    equivalent of `setpos()` on `'v'` for a cursor >lua
    --- @param pos SimplePos | Pos
    --- @return self
<
    Parameters: ~
      • {pos} (`SimplePos | Pos`) new position of the anchor

    Return: ~
      • (`self`) cursor

    See also: ~
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|
      • |Visual|
      • |setpos()|

Cursor:getVisualAnchor()                  *multicursor-Cursor-getVisualAnchor*
    Returns the position of cursor's visual anchor 
    same as `getpos('v')` >lua
    --- @return Pos
<
    Return: ~
      • (`Pos`) position of the anchor

    See also: ~
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|
      • |Visual|
      • |getpos()|

Cursor:setRedoChangePos({pos})           *multicursor-cursor-setRedoChangePos*
    Sets the position of the redo position marker >lua
    --- @param pos SimplePos | Pos
<
    Parameters: ~
      • {pos} (`table`) new position that is either `SimplePos` or `Pos`

    See also: ~
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|

Cursor:clone()                                      *multicursor-cursor-clone*
    Returns a new cursor with the same position, registers,
    visual selection, and mode as this cursor. >lua
    --- @return Cursor
<
    Return: ~
      • (`Cursor`) full copy of the cursor

    See also: ~
      • |multicursor-API-Cursor|

Cursor:getVisualLines()                    *multicursor-Cursor-getVisualLines*
    Returns only the text contained in each line of the visual selection. >lua
    --- @return string[]
<
    Return: ~
      • (`table`) table containing the lines that are only in the visual
        selection

Cursor:getFullVisualLines()            *multicursor-Cursor-getFullVisualLines*
    Returns the full line for each line of the visual selection. >lua
    --- @return string[]
<
    Return: ~
      • (`table`) same as `'<,'>` for a cursor

Cursor:getVisual()                              *multicursor-cursor-getVisual*
    Returns start and end positions of visual selection start position
    is before or equal to end position. >lua
    --- @return Pos, Pos
<
    Return: ~
      • (`Pos`) starting position of the visual selection
      • (`Pos`) ending position of the visual selection

    See also: ~
      • |multicursor-types-Pos|

Cursor:mode()                                        *multicursor-cursor-mode*
    Returns this cursor's current mode.
    It should only ever be in normal, visual, or select modes. >lua
    --- @return string: "n" | "v" | "V" | <c-v> | "s" | "S" | <c-s>
>
    Return: ~
      • (`string`) mode of the cursor

    See also: ~
      • |mode()|

Cursor:setMode({mode})                            *multicursor-cursor-setMode*
--- Sets this cursor's mode.
--- It should only ever be in normal, visual, or select modes. >lua
    --- @param mode string: "n" | "v" | "V" | <c-v> | "s" | "S" | <c-s>
    --- @return self
<
    Parameters: ~
      • (`string`) new mode of the cursor

    Return: ~
      • (`self`) cursor

    See also: ~
      • |mode()|

Cursor:disable()                                  *multicursor-cursor-disable*
    Disable the cursor

Cursor:enable()                                    *multicursor-cursor-enable*
    Enable the cursor

Cursor:feedkeys({keys}, {opts?})                 *multicursor-cursor-feedkeys*
    Makes the cursor perform a command/commands.
    For example, cursor:feedkeys('dw') will delete a word.
    By default, keys are not remapped and keycodes are not parsed. >lua
    --- @param keys string
    --- @param opts? { remap?: boolean, keycodes?: boolean }
<
    Parameters: ~
      • {keys} (`string`) string representing a command
      • {opts} (`table`) options
        • {opts.remap} (`boolean?`) if true use remapped keys
        • {opts.keycodes} (`boolean?`) if true translate keycodes

Cursor:perform({callback})                        *multicursor-cursor-perform*
    Call callback with cursor >lua
    --- @param callback fun(cursor: Cursor)
<
    Parameters: ~
      • {callback} (`function`) function to execute on a cursor

    See also: ~
      • |multicursor-API-Cursor|

Cursor:getCursorWord({callback})            *multicursor-cursor-getCursorWord*
    Return the <cword> for this cursor >lua
    --- @return string
<
    Return: ~
      • (`string`) current word under cursor

    See also: ~
      • |<cword>|

Cursor:setSearch({search})                      *multicursor-cursor-setSearch*
    Set the search register of this cursor >lua
    --- @param search string
<
    Parameters: ~
      • (`string`) new content of the register

    See also: ~
      • |/|

Cursor:setVisual({visualStart}, {visualEnd})    *multicursor-cursor-setVisual*
    Sets the visual selection and sets the cursor position to `visualEnd`. >lua
    --- @param visualStart SimplePos | Pos
    --- @param visualEnd SimplePos | Pos
    --- @return self
<
    Parameters: ~
      • {visualStart} (`SimplePos | Pos`) start position of the visual
        selection
      • {visualEnd} (`SimplePos | Pos`) end position of the visual selection

    See also: ~
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|
      • |Visual|

Cursor:inVisualMode()                        *multicursor-cursor-inVisualMode*
    Returns true if cursor is in visual mode >lua
    --- @return boolean
<
    Return: ~
      • (`boolean`) true if cursor is in visual mode

    See also: ~
      • |Visual|

Cursor:inSelectMode()                        *multicursor-cursor-inSelectMode*
    Returns true if cursor is in select mode >lua
    --- @return boolean
<
    Return: ~
      • (`boolean`) true if cursor is in select mode

    See also: ~
      • |Select|

Cursor:hasSelection()                        *multicursor-cursor-hasSelection*
    Returns true if cursor is in visual or select mode >lua
    --- @return boolean
<
    Return: ~
      • (`boolean`) true if either in select or visual mode

    See also: ~
      • |Visual|
      • |Select|

vim:tw=78:ts=8:noet:ft=help:norl:
